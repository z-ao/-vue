# 面向过程了解框架
>runtime版本

+ 引入vue文件运行什么操作
+ 创建vue实例运行什么逻辑

## 引入vue文件运行什么操作
与大部分库引入时相似，正常做以下3点操作。   
1. 声明类   
2. 定义类原型对象   
3. 定义类的静态属性       



从入口的文件追溯到Vue的声明文件    
我们得到以下文件依赖路径   
platforms/web/entry-runtime->  
platforms/web/runtime/index->   
core/index->   
core/instance/index。   
然后我们反向分析，就可得知Vue声明到封装的一系列的过程。

### core/instance/index
```
...
...
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue) //创建init方法，在new一个实例是调用
stateMixin(Vue) //创建model层相关属性，$data、$props、$watch、$delete、$set
eventsMixin(Vue) //创建事件通信相关属性，$on、$emit、$off、$once
lifecycleMixin(Vue) //创建声明周期相关属性，_update、$forceUpdate、$destroy
renderMixin(Vue) //创建渲染相关属性，$nextTick、_render

export default Vue

```
第一步是声明Vue构造函数，并且定义与原型对象的属性   
1. 初始化方法   
2. model层相关属性   
3. 事件通信相关属性   
4. 声明周期相关属性   
5. 渲染相关属性

### core/index
```
...
...
initGlobalAPI(Vue) // 定义静态属性

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

Vue.version = '__VERSION__'

export default Vue
```

查看 core/global-api/index

```
...
...
export function initGlobalAPI (Vue: GlobalAPI) {
  // 设置全局配置项
  ...
  ...
  Object.defineProperty(Vue, 'config', configDef)

  // 设置响应式相关方法
  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  Vue.observable = <T>(obj: T): T => {
    observe(obj)
    return obj
  }

  ...
  ...
  // 注册内置的组件
  extend(Vue.options.components, builtInComponents)

  initUse(Vue) //定义use插件按装
  initMixin(Vue) //定义mixin混入方法
  initExtend(Vue) //定义extend 子类构造器
  initAssetRegisters(Vue) //定义component directive filter方法
}
```
当前文件是定义服务端渲染属性，    
以及Vue的全部静态属性
extend、nextTick、set、delete、directive、filter、component、use、mixin、observable、version。（除了compile，因为当前方法只提供complier + runtime版本）

### platforms/web/runtime/index
```
...
...
// 设置与平台相关属性
Vue.config.mustUseProp = mustUseProp
Vue.config.isReservedTag = isReservedTag
Vue.config.isReservedAttr = isReservedAttr
Vue.config.getTagNamespace = getTagNamespace
Vue.config.isUnknownElement = isUnknownElement

// 设置全局指令和组件
extend(Vue.options.directives, platformDirectives) //model show
extend(Vue.options.components, platformComponents) // Transition TransitionGroup

// 设置patch方法
Vue.prototype.__patch__ = inBrowser ? patch : noop

// 定义挂载方法
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```
当前文件是定义与平台和库类型特有的属性与方法、组件。

### platforms/web/entry-runtime
```
import Vue from './runtime/index'

export default Vue
```
直接引入文件，    
因为compiler版本需要在runtime/index基础上添加私有方法，   
所以创建不同的入口。 

## 创建vue实例运行什么逻辑

在 core/instance/index 文件中，   
我们可以看到创建实例时，   
调用了 _init 方法并传入 options。

```
import { initMixin } from './init'
...
...
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue) //创建init方法，在new一个实例是调用
```
所以整个 new 主逻辑在 core/instance/init 文件定义。

```
export function initMixin (Vue: Class<Component>) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    // 创建实例id
    vm._uid = uid++

    ...
    ...

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    // 合并 options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }

    ...
    ...
    
    initLifecycle(vm) //初始化声明周期
    initEvents(vm) //初始化事件 定义_event属性存储事件、处理父组件事件
    initRender(vm) //初始化渲染 获取slots 定义$createElement
    callHook(vm, 'beforeCreate') // 调用beforeCreate事件
    //获取注入的inject
    initInjections(vm) // resolve injections before data/props 
    initState(vm) // 处理 prop method data computed watch 属性
    // 因为 provide 可以是函数或对象 统一值
    initProvide(vm) // resolve provide after data/props 
    callHook(vm, 'created') // 调用created事件

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el) //挂载
    }
  }
}
```
整个主线流程很清晰，每个功能逻辑拆分到不同文件中。     
1. 合并options   
2. 初始化声明周期   
3. 初始化事件   
4. 调用beforeCreate事件   
5. 获取注入的inject   
6. 处理 prop method data computed watch 属性   
7. 统一provide值   
8. 调用created事件   
9. （可选）如果提供 el 挂载
