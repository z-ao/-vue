# 问题驱动了解原理

<a href="#vue只是不能监听到对象的属性增删吗">vue只是不能监听到对象的属性增删吗?</a>

## vue只是不能监听到对象的属性增删吗
我们知道,要给响应式对象增/删属性时,要使用set/delete方法.   
因为这是js的***Object.defineProperty***的限制

```
var _obj = {}
Object.defineProperty(window, 'obj', {
  get() {
    return _obj
  },
  set(val) {
    console.log('i set obj')
    _obj = val
    return _obj
  }
})
obj.a = 'a' //没有打i set obj
console.log(obj) //{a: 'a'}
```

其实,它不仅不能监听到对象属性的增删,还不能监听到该对象调用原生方法的修改

```
var _obj = new Date
Object.defineProperty(window, 'obj', {
  get() {
    return _obj
  },
  set(val) {
    console.log('i set obj')
    _obj = val
    return _obj
  }
})
obj.setDate(1) //没有打i set obj
console.log(obj.toLocaleString()) //xxxx/xx/1 xxxx:xx:xx
```

那么,为什么调用数组的原生方法可以监听到？

```
源码
core/observer/index


export class Observer {
  ...
  ...

  constructor (value: any) {
	 ...
	 ...
    if (Array.isArray(value)) { //数组类型
      ...
      ...
      augment(value, arrayMethods, arrayKeys) //把arrayMethods的方法绑定在value上
      this.observeArray(value) 
    } else {
		...
		...
    }
  }
 
 
arrayMethods方法
core/observer/array


const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto) //拷贝数组方法

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]


methodsToPatch.forEach(function (method) {

  const original = arrayProto[method] //原生方法
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args) //调用原生方法,存下返回值
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted) //如果是新增,把它变为观察者

    ob.dep.notify() //通知订阅者
    return result
  })
})
```

由源码看出,通过劫持响应式数组的原生方法,来做依赖的收集和通知订阅者.